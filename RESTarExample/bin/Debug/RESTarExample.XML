<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RESTarExample</name>
    </assembly>
    <members>
        <member name="T:RESTarExample.RESTarEmployee">
            <summary>
            By assigning the RESTar attribute and providing either the methods we want
            to enable, or a preset like ReadAndWrite (enables all methods), we register
            this class as a RESTar resource. This also makes it subject for serialization
            and deserialization to JSON objects, which we need to keep in mind when 
            designing our Starcounter data model and decide what should be exposed to RESTar.
            </summary>
        </member>
        <member name="P:RESTarExample.RESTarEmployee.Boss">
            <summary>
            'Boss' is an object reference. When serializing an entity in the resource 
            RESTarPerson (a row in this table), RESTar will serialize the 'Boss' column
            as an inner JSON object. Example:
            {
                "Name": "Tim Canterbury",
                "Title": "Sales rep",
                "Boss": {
                    "Name": "David Brent",
                    "Title": "Mentor, Entertainer, Renaissance man"
                    // David has no boss
                } 
            }
            Often this is acceptable, but it can be problematic. If we want to ignore a 
            column (field or property) in a resource when serializing or deserializing a 
            JSON object, we decorate the corresponding member with the .NET standard 
            IgnoreDataMember attribute. In this case the reference is possibly recursive 
            (the boss may have a boss etc.) which makes it appropriate to ignore this column. 
            We can always include a new member holding the boss' ObjectNo though if we still 
            want to print useful information from the 'Boss' column. Substituting ObjectNo
            for object references in tables is how the Starcounter Administrator handles 
            this, so let's implement an similar pattern here where the 'Boss' column is
            decided by an ObjectNo, and not by an object reference.
            </summary>
        </member>
        <member name="F:RESTarExample.RESTarEmployee.bossObjectNo">
            <summary>
            If we want to give the serializer another name than 'bossObjectNo' to use as 
            JSON member name, we can provide an alias using the .NET standard DataMember 
            attribute. This way we still have control over what the resulting JSON will 
            look like.
            </summary>
        </member>
        <member name="P:RESTarExample.RESTarEmployee.Underlings">
            <summary>
            Since the 'Boss' member is ignored, we can decide whether to include the 
            'Underlings' column or not. Had we included both, the serializer would detect
            the infinite recursion and throw an exception when matching entities in this 
            resource. In this case, let's include 'Underlings'.
            </summary>
        </member>
    </members>
</doc>
